<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verificador Provably Fair - Stake</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: fadeIn 0.8s ease-in;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            animation: slideUp 0.5s ease-out;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95em;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(255,255,255,0.15);
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .input-group input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #fff;
            background: rgba(255,255,255,0.25);
        }

        .input-group select option {
            background: #667eea;
            color: #fff;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .results {
            margin-top: 30px;
        }

        .result-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .result-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        .result-number {
            font-size: 1.3em;
            font-weight: 700;
        }

        .result-details {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .chart-container {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            display: none;
        }

        .chart-container.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
            display: none;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.15);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé≤ Verificador Provably Fair</h1>
            <p>Verifica la justicia de tus tiradas en Stake.com</p>
        </div>

        <div class="card">
            <h2 style="margin-bottom: 20px;">‚öôÔ∏è Configuraci√≥n</h2>
            
            <div class="input-group">
                <label>Juego</label>
                <select id="gameType">
                    <option value="roulette">üé° Roulette</option>
                    <option value="dice">üé≤ Dice</option>
                    <option value="limbo">üöÄ Limbo</option>
                    <option value="mines">üí£ Mines</option>
                </select>
            </div>

            <div class="grid-2">
                <div class="input-group">
                    <label>Server Seed (Hash)</label>
                    <input type="text" id="serverSeed" placeholder="Ej: abc123...">
                </div>
                <div class="input-group">
                    <label>Client Seed</label>
                    <input type="text" id="clientSeed" placeholder="Ej: xyz789...">
                </div>
            </div>

            <div class="grid-2">
                <div class="input-group">
                    <label>Nonce Inicial</label>
                    <input type="number" id="nonce" value="0" min="0">
                </div>
                <div class="input-group">
                    <label>N√∫mero de Tiradas</label>
                    <input type="number" id="rounds" value="100" min="1" max="1000000">
                </div>
            </div>

            <div id="minesConfig" style="display: none;">
                <div class="input-group">
                    <label>N√∫mero de Minas</label>
                    <input type="number" id="minesCount" value="3" min="1" max="24">
                </div>
            </div>

            <button class="btn" onclick="calculate()">üîç Calcular Resultados</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Calculando resultados...</p>
        </div>

        <div class="card" id="resultsCard" style="display: none;">
            <h2 style="margin-bottom: 20px;">üìä Resultados</h2>
            
            <div class="stats" id="stats"></div>

            <div class="results" id="results"></div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
                <button class="btn" onclick="showCharts()">üìà Ver Gr√°ficos</button>
                <button class="btn" onclick="exportToExcel()" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);">üìä Exportar a Excel</button>
            </div>
        </div>

        <div class="chart-container" id="chartContainer">
            <canvas id="resultChart"></canvas>
            
            <div id="rouletteStats" style="display: none; margin-top: 30px;">
                <h3 style="color: #333; margin-bottom: 20px; font-size: 1.5em;">üìä An√°lisis Avanzado de Ruleta</h3>
                
                <div style="background: linear-gradient(135deg, #134e5e 0%, #71b280 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">üìä Frecuencia de Rachas Consecutivas</h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 20px; font-size: 0.95em;">Cu√°ntas veces un n√∫mero cualquiera no sale durante X tiradas consecutivas</p>
                    <div id="streakFrequencyContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;"></div>
                </div>

                <div style="background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">üî• Rachas M√°ximas sin Salir</h4>
                    <div id="maxStreaksContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;"></div>
                </div>

                <div style="background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">üìà Frecuencia Media de Aparici√≥n</h4>
                    <div id="avgFrequencyContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;"></div>
                </div>

                <div style="background: linear-gradient(135deg, #16a085 0%, #f4d03f 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">‚è±Ô∏è Media Aparici√≥n tras 130 Tiradas sin Salir</h4>
                    <div id="after130Container"></div>
                </div>

                <div style="background: linear-gradient(135Â∫¶, #2980b9 0%, #6dd5fa 50%, #ffffff 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">‚è±Ô∏è Media Aparici√≥n tras 160 Tiradas sin Salir</h4>
                    <div id="after160Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">‚è±Ô∏è Media Aparici√≥n tras 190 Tiradas sin Salir</h4>
                    <div id="after190Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #134e5e 0%, #71b280 100%); padding: 25px; border-radius: 15px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">‚è±Ô∏è Media Aparici√≥n tras 220 Tiradas sin Salir</h4>
                    <div id="after220Container"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let calculatedResults = [];
        let currentGame = 'roulette';

        document.getElementById('gameType').addEventListener('change', function() {
            currentGame = this.value;
            document.getElementById('minesConfig').style.display = 
                currentGame === 'mines' ? 'block' : 'none';
        });

        // Implementaci√≥n EXACTA del algoritmo Provably Fair de Stake
        function byteGenerator(serverSeed, clientSeed, nonce, cursor) {
            let currentRound = cursor;
            let currentRoundCursor = 0;
            
            return {
                next: function() {
                    if (currentRoundCursor === 32) {
                        currentRoundCursor = 0;
                        currentRound += 1;
                    }
                    const hmac = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:${currentRound}`, serverSeed);
                    const buffer = hmac.toString(CryptoJS.enc.Hex);
                    const byte = parseInt(buffer.substring(currentRoundCursor * 2, currentRoundCursor * 2 + 2), 16);
                    currentRoundCursor += 1;
                    return { value: byte };
                }
            };
        }

        function generateFloats(serverSeed, clientSeed, nonce, cursor, count) {
            const rng = byteGenerator(serverSeed, clientSeed, nonce, cursor);
            const bytes = [];
            
            while (bytes.length < count * 4) {
                bytes.push(rng.next().value);
            }
            
            const floats = [];
            for (let i = 0; i < count; i++) {
                const chunk = bytes.slice(i * 4, i * 4 + 4);
                let result = 0;
                for (let j = 0; j < 4; j++) {
                    const divider = Math.pow(256, j + 1);
                    result += chunk[j] / divider;
                }
                floats.push(result);
            }
            
            return floats;
        }

        function generateResult(serverSeed, clientSeed, nonce, game, minesCount = 3) {
            switch(game) {
                case 'roulette':
                    return calculateRoulette(serverSeed, clientSeed, nonce);
                case 'dice':
                    return calculateDice(serverSeed, clientSeed, nonce);
                case 'limbo':
                    return calculateLimbo(serverSeed, clientSeed, nonce);
                case 'mines':
                    return calculateMines(serverSeed, clientSeed, nonce, minesCount);
                default:
                    return null;
            }
        }

        function calculateRoulette(serverSeed, clientSeed, nonce) {
            const floats = generateFloats(serverSeed, clientSeed, nonce, 0, 1);
            const result = Math.floor(floats[0] * 37);
            
            let color = 'verde';
            if (result !== 0) {
                const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
                color = redNumbers.includes(result) ? 'rojo' : 'negro';
            }
            
            const hash = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:0`, serverSeed).toString().substring(0, 8);
            
            return {
                value: result,
                display: result,
                color: color,
                hash: hash
            };
        }

        function calculateDice(serverSeed, clientSeed, nonce) {
            const floats = generateFloats(serverSeed, clientSeed, nonce, 0, 1);
            // Documentaci√≥n oficial: (float * 10001) / 100
            const result = (floats[0] * 10001) / 100;
            
            const hash = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:0`, serverSeed).toString().substring(0, 8);
            
            return {
                value: result,
                display: result.toFixed(2),
                hash: hash
            };
        }

        function calculateLimbo(serverSeed, clientSeed, nonce) {
            const floats = generateFloats(serverSeed, clientSeed, nonce, 0, 1);
            const houseEdge = 0.99; // 1% house edge
            
            // Documentaci√≥n oficial de Stake:
            // const floatPoint = 1e8 / (float * 1e8) * houseEdge;
            // const crashPoint = Math.floor(floatPoint * 100) / 100;
            const floatPoint = (1e8 / (floats[0] * 1e8)) * houseEdge;
            const result = Math.max(1, Math.floor(floatPoint * 100) / 100);
            
            const hash = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:0`, serverSeed).toString().substring(0, 8);
            
            return {
                value: result,
                display: result.toFixed(2) + 'x',
                hash: hash
            };
        }

        function calculateMines(serverSeed, clientSeed, nonce, minesCount) {
            const gridSize = 25;
            // Generar floats seg√∫n cantidad de minas
            const floats = generateFloats(serverSeed, clientSeed, nonce, 0, minesCount);
            const positions = [];
            
            // Fisher-Yates shuffle seg√∫n documentaci√≥n oficial
            const deck = Array.from({length: gridSize}, (_, i) => i);
            
            for (let i = 0; i < minesCount; i++) {
                const index = Math.floor(floats[i] * deck.length);
                positions.push(deck[index]);
                deck.splice(index, 1);
            }
            
            positions.sort((a, b) => a - b);
            
            const hash = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:0`, serverSeed).toString().substring(0, 8);
            
            return {
                value: positions,
                display: positions.join(', '),
                hash: hash,
                positions: positions
            };
        }

        async function calculate() {
            const serverSeed = document.getElementById('serverSeed').value.trim();
            const clientSeed = document.getElementById('clientSeed').value.trim();
            const startNonce = parseInt(document.getElementById('nonce').value);
            const rounds = parseInt(document.getElementById('rounds').value);
            const minesCount = parseInt(document.getElementById('minesCount').value);

            if (!serverSeed || !clientSeed) {
                alert('Por favor ingresa ambas seeds');
                return;
            }

            if (rounds > 1000000) {
                alert('M√°ximo 1,000,000 de tiradas');
                return;
            }

            if (rounds > 50000) {
                if (!confirm(`Vas a calcular ${rounds.toLocaleString()} tiradas. Esto puede tomar algunos segundos. ¬øContinuar?`)) {
                    return;
                }
            }

            document.getElementById('loading').classList.add('active');
            document.getElementById('resultsCard').style.display = 'none';
            document.getElementById('chartContainer').classList.remove('active');
            
            calculatedResults = [];

            // Procesar en chunks para no bloquear la UI
            const chunkSize = 1000;
            let processed = 0;

            async function processChunk() {
                const end = Math.min(processed + chunkSize, rounds);
                
                for (let i = processed; i < end; i++) {
                    const result = generateResult(serverSeed, clientSeed, startNonce + i, currentGame, minesCount);
                    calculatedResults.push({
                        nonce: startNonce + i,
                        ...result
                    });
                }
                
                processed = end;
                
                // Actualizar progreso
                const progress = ((processed / rounds) * 100).toFixed(1);
                document.getElementById('loading').innerHTML = `
                    <div class="spinner"></div>
                    <p>Calculando resultados... ${progress}%</p>
                    <p style="opacity: 0.7; font-size: 0.9em;">${processed.toLocaleString()} / ${rounds.toLocaleString()} tiradas</p>
                `;
                
                if (processed < rounds) {
                    // Permitir que el navegador respire entre chunks
                    await new Promise(resolve => setTimeout(resolve, 10));
                    await processChunk();
                }
            }

            await processChunk();

            displayResults();
            document.getElementById('loading').classList.remove('active');
            document.getElementById('resultsCard').style.display = 'block';
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            const statsDiv = document.getElementById('stats');
            
            // Mostrar estad√≠sticas
            const stats = calculateStats();
            statsDiv.innerHTML = `
                ${stats.map(stat => `
                    <div class="stat-card">
                        <div class="stat-value">${stat.value}</div>
                        <div class="stat-label">${stat.label}</div>
                    </div>
                `).join('')}
            `;

            // Mostrar primeros 50 resultados
            const displayLimit = Math.min(50, calculatedResults.length);
            resultsDiv.innerHTML = `
                <h3 style="margin-bottom: 15px;">Primeros ${displayLimit} resultados:</h3>
                ${calculatedResults.slice(0, displayLimit).map(r => `
                    <div class="result-item">
                        <div>
                            <span class="result-number">${r.display}</span>
                            ${r.color ? `<span style="margin-left: 10px; padding: 5px 10px; background: ${r.color === 'rojo' ? '#e74c3c' : r.color === 'negro' ? '#2c3e50' : '#27ae60'}; border-radius: 5px;">${r.color}</span>` : ''}
                        </div>
                        <div class="result-details">
                            Nonce: ${r.nonce} | Hash: ${r.hash}
                        </div>
                    </div>
                `).join('')}
                ${calculatedResults.length > displayLimit ? `<p style="text-align: center; margin-top: 20px; opacity: 0.8;">... y ${calculatedResults.length - displayLimit} resultados m√°s</p>` : ''}
            `;
        }

        function calculateStats() {
            const total = calculatedResults.length;
            
            switch(currentGame) {
                case 'roulette':
                    const reds = calculatedResults.filter(r => r.color === 'rojo').length;
                    const blacks = calculatedResults.filter(r => r.color === 'negro').length;
                    const greens = calculatedResults.filter(r => r.color === 'verde').length;
                    return [
                        { label: 'Total Tiradas', value: total },
                        { label: 'Rojos', value: reds + ` (${(reds/total*100).toFixed(1)}%)` },
                        { label: 'Negros', value: blacks + ` (${(blacks/total*100).toFixed(1)}%)` },
                        { label: 'Verdes', value: greens + ` (${(greens/total*100).toFixed(1)}%)` }
                    ];
                
                case 'dice':
                    const avg = calculatedResults.reduce((sum, r) => sum + r.value, 0) / total;
                    const under50 = calculatedResults.filter(r => r.value < 50).length;
                    return [
                        { label: 'Total Tiradas', value: total },
                        { label: 'Promedio', value: avg.toFixed(2) },
                        { label: 'Bajo 50', value: under50 + ` (${(under50/total*100).toFixed(1)}%)` },
                        { label: 'Sobre 50', value: (total-under50) + ` (${((total-under50)/total*100).toFixed(1)}%)` }
                    ];
                
                case 'limbo':
                    const avgMultiplier = calculatedResults.reduce((sum, r) => sum + r.value, 0) / total;
                    const over2x = calculatedResults.filter(r => r.value >= 2).length;
                    const over10x = calculatedResults.filter(r => r.value >= 10).length;
                    return [
                        { label: 'Total Tiradas', value: total },
                        { label: 'Promedio', value: avgMultiplier.toFixed(2) + 'x' },
                        { label: 'Sobre 2x', value: over2x + ` (${(over2x/total*100).toFixed(1)}%)` },
                        { label: 'Sobre 10x', value: over10x + ` (${(over10x/total*100).toFixed(1)}%)` }
                    ];
                
                case 'mines':
                    return [
                        { label: 'Total Tiradas', value: total },
                        { label: 'Minas por Juego', value: document.getElementById('minesCount').value },
                        { label: 'Casillas Totales', value: '25' },
                        { label: 'Configuraciones', value: total }
                    ];
            }
        }

        function showCharts() {
            const chartContainer = document.getElementById('chartContainer');
            chartContainer.classList.add('active');
            
            const ctx = document.getElementById('resultChart').getContext('2d');
            
            // Destruir gr√°fico anterior si existe
            if (window.myChart) {
                window.myChart.destroy();
            }

            let chartData = prepareChartData();
            
            window.myChart = new Chart(ctx, {
                type: chartData.type,
                data: chartData.data,
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#333', font: { size: 14 } }
                        },
                        title: {
                            display: true,
                            text: chartData.title,
                            color: '#333',
                            font: { size: 18, weight: 'bold' }
                        }
                    },
                    scales: chartData.scales
                }
            });

            // Mostrar estad√≠sticas avanzadas de ruleta
            if (currentGame === 'roulette') {
                document.getElementById('rouletteStats').style.display = 'block';
                calculateRouletteAdvancedStats();
            } else {
                document.getElementById('rouletteStats').style.display = 'none';
            }

            chartContainer.scrollIntoView({ behavior: 'smooth' });
        }

        function prepareChartData() {
            switch(currentGame) {
                case 'roulette':
                    const distribution = {};
                    for (let i = 0; i <= 36; i++) distribution[i] = 0;
                    calculatedResults.forEach(r => distribution[r.value]++);
                    
                    return {
                        type: 'bar',
                        title: 'Distribuci√≥n de N√∫meros en Roulette',
                        data: {
                            labels: Object.keys(distribution),
                            datasets: [{
                                label: 'Frecuencia',
                                data: Object.values(distribution),
                                backgroundColor: Object.keys(distribution).map(n => {
                                    if (n == 0) return '#27ae60';
                                    const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
                                    return redNumbers.includes(parseInt(n)) ? '#e74c3c' : '#2c3e50';
                                })
                            }]
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#333' }
                            },
                            x: { 
                                ticks: { color: '#333' }
                            }
                        }
                    };
                
                case 'dice':
                    const bins = 10;
                    const binCounts = new Array(bins).fill(0);
                    calculatedResults.forEach(r => {
                        const bin = Math.min(Math.floor(r.value / 10), bins - 1);
                        binCounts[bin]++;
                    });
                    
                    return {
                        type: 'bar',
                        title: 'Distribuci√≥n de Resultados en Dice',
                        data: {
                            labels: Array.from({length: bins}, (_, i) => `${i*10}-${(i+1)*10}`),
                            datasets: [{
                                label: 'Frecuencia',
                                data: binCounts,
                                backgroundColor: '#3498db'
                            }]
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#333' }
                            },
                            x: { 
                                ticks: { color: '#333' }
                            }
                        }
                    };
                
                case 'limbo':
                    const ranges = [
                        {label: '1-2x', min: 1, max: 2},
                        {label: '2-5x', min: 2, max: 5},
                        {label: '5-10x', min: 5, max: 10},
                        {label: '10-50x', min: 10, max: 50},
                        {label: '50x+', min: 50, max: Infinity}
                    ];
                    const rangeCounts = ranges.map(range => 
                        calculatedResults.filter(r => r.value >= range.min && r.value < range.max).length
                    );
                    
                    return {
                        type: 'pie',
                        title: 'Distribuci√≥n de Multiplicadores en Limbo',
                        data: {
                            labels: ranges.map(r => r.label),
                            datasets: [{
                                data: rangeCounts,
                                backgroundColor: ['#3498db', '#9b59b6', '#e74c3c', '#f39c12', '#27ae60']
                            }]
                        },
                        scales: {}
                    };
                
                case 'mines':
                    const positionFreq = new Array(25).fill(0);
                    calculatedResults.forEach(r => {
                        r.positions.forEach(pos => positionFreq[pos]++);
                    });
                    
                    return {
                        type: 'bar',
                        title: 'Frecuencia de Minas por Posici√≥n',
                        data: {
                            labels: Array.from({length: 25}, (_, i) => i.toString()),
                            datasets: [{
                                label: 'Frecuencia',
                                data: positionFreq,
                                backgroundColor: '#e74c3c'
                            }]
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#333' }
                            },
                            x: { 
                                ticks: { color: '#333' }
                            }
                        }
                    };
            }
        }

        function calculateRouletteAdvancedStats() {
            // 0. Calcular frecuencia de rachas consecutivas sin salir
            const streakThresholds = [130, 160, 190, 220, 300, 350];
            const streakCounts = {};
            streakThresholds.forEach(t => streakCounts[t] = 0);
            
            // Contar rachas para cada n√∫mero
            for (let num = 0; num <= 36; num++) {
                let streak = 0;
                
                calculatedResults.forEach((result, index) => {
                    if (result.value !== num) {
                        streak++;
                        
                        // Verificar si alcanzamos alg√∫n umbral
                        streakThresholds.forEach(threshold => {
                            if (streak === threshold) {
                                streakCounts[threshold]++;
                            }
                        });
                    } else {
                        streak = 0;
                    }
                });
            }
            
            // 1. Calcular racha m√°xima sin salir para cada n√∫mero
            const maxStreaks = {};
            const lastSeen = {};
            const currentStreak = {};
            
            for (let num = 0; num <= 36; num++) {
                maxStreaks[num] = { streak: 0, startNonce: 0, endNonce: 0 };
                currentStreak[num] = { count: 0, startNonce: 0 };
                lastSeen[num] = -1;
            }
            
            calculatedResults.forEach((result, index) => {
                const num = result.value;
                
                // Actualizar para todos los n√∫meros excepto el que sali√≥
                for (let n = 0; n <= 36; n++) {
                    if (n !== num) {
                        if (currentStreak[n].count === 0) {
                            currentStreak[n].startNonce = result.nonce;
                        }
                        currentStreak[n].count++;
                        
                        // Actualizar m√°ximo si es necesario
                        if (currentStreak[n].count > maxStreaks[n].streak) {
                            maxStreaks[n] = {
                                streak: currentStreak[n].count,
                                startNonce: currentStreak[n].startNonce,
                                endNonce: result.nonce
                            };
                        }
                    } else {
                        // El n√∫mero sali√≥, reiniciar su racha
                        currentStreak[n] = { count: 0, startNonce: 0 };
                        lastSeen[n] = index;
                    }
                }
            });

            // 2. Calcular frecuencia media de aparici√≥n
            const appearances = {};
            for (let num = 0; num <= 36; num++) {
                appearances[num] = [];
            }
            
            calculatedResults.forEach((result, index) => {
                appearances[result.value].push(index);
            });

            const avgFrequency = {};
            for (let num = 0; num <= 36; num++) {
                if (appearances[num].length > 1) {
                    const intervals = [];
                    for (let i = 1; i < appearances[num].length; i++) {
                        intervals.push(appearances[num][i] - appearances[num][i - 1]);
                    }
                    avgFrequency[num] = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                } else {
                    avgFrequency[num] = appearances[num].length === 1 ? calculatedResults.length : 0;
                }
            }

            // 3-6. Calcular media de aparici√≥n despu√©s de X tiradas sin salir
            const thresholds = [130, 160, 190, 220];
            const afterThreshold = {};
            
            thresholds.forEach(threshold => {
                afterThreshold[threshold] = {};
                for (let num = 0; num <= 36; num++) {
                    afterThreshold[threshold][num] = [];
                }
            });

            for (let num = 0; num <= 36; num++) {
                let streak = 0;
                let streakStart = 0;
                
                calculatedResults.forEach((result, index) => {
                    if (result.value !== num) {
                        if (streak === 0) streakStart = index;
                        streak++;
                        
                        // Verificar umbrales
                        thresholds.forEach(threshold => {
                            if (streak === threshold) {
                                // Buscar cu√°ndo aparece despu√©s
                                for (let j = index + 1; j < calculatedResults.length; j++) {
                                    if (calculatedResults[j].value === num) {
                                        afterThreshold[threshold][num].push(j - index);
                                        break;
                                    }
                                }
                            }
                        });
                    } else {
                        streak = 0;
                    }
                });
            }

            // Mostrar resultados
            displayStreakFrequency(streakCounts);
            displayMaxStreaks(maxStreaks);
            displayAvgFrequency(avgFrequency);
            displayAfterThreshold(afterThreshold, 130, 'after130Container');
            displayAfterThreshold(afterThreshold, 160, 'after160Container');
            displayAfterThreshold(afterThreshold, 190, 'after190Container');
            displayAfterThreshold(afterThreshold, 220, 'after220Container');
        }

        function displayStreakFrequency(streakCounts) {
            const container = document.getElementById('streakFrequencyContainer');
            
            const entries = Object.entries(streakCounts).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
            
            container.innerHTML = entries.map(([threshold, count]) => `
                <div style="background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); text-align: center; transition: transform 0.3s ease;">
                    <div style="font-size: 2.5em; font-weight: 700; color: #134e5e; margin-bottom: 8px;">${count}</div>
                    <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">veces ocurri√≥</div>
                    <div style="font-size: 1.1em; font-weight: 600; color: #2c3e50;">
                        Racha de <span style="color: #e74c3c;">${threshold}</span> tiradas
                    </div>
                </div>
            `).join('');
        }

        function displayMaxStreaks(maxStreaks) {
            const container = document.getElementById('maxStreaksContainer');
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            
            // Ordenar por racha m√°s larga
            const sorted = Object.entries(maxStreaks).sort((a, b) => b[1].streak - a[1].streak);
            
            container.innerHTML = sorted.slice(0, 10).map(([num, data]) => {
                const color = num == 0 ? '#27ae60' : redNumbers.includes(parseInt(num)) ? '#e74c3c' : '#2c3e50';
                return `
                    <div style="background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                            <span style="font-size: 1.8em; font-weight: 700; color: ${color};">${num}</span>
                            <span style="font-size: 1.5em; font-weight: 700; color: #e74c3c;">${data.streak}</span>
                        </div>
                        <div style="font-size: 0.85em; color: #666;">
                            <strong>Tiradas sin salir</strong><br>
                            Nonces: ${data.startNonce} ‚Üí ${data.endNonce}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function displayAvgFrequency(avgFrequency) {
            const container = document.getElementById('avgFrequencyContainer');
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            
            container.innerHTML = Object.entries(avgFrequency).map(([num, freq]) => {
                const color = num == 0 ? '#27ae60' : redNumbers.includes(parseInt(num)) ? '#e74c3c' : '#2c3e50';
                return `
                    <div style="background: white; padding: 12px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: space-between;">
                        <span style="font-size: 1.4em; font-weight: 700; color: ${color};">${num}</span>
                        <span style="font-size: 1.2em; font-weight: 600; color: #333;">${freq > 0 ? freq.toFixed(1) : 'N/A'} <small style="font-size: 0.7em; opacity: 0.7;">rolls</small></span>
                    </div>
                `;
            }).join('');
        }

        function displayAfterThreshold(afterThreshold, threshold, containerId) {
            const container = document.getElementById(containerId);
            const data = afterThreshold[threshold];
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            
            const stats = Object.entries(data).map(([num, values]) => {
                const avg = values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
                const occurrences = values.length;
                return { num: parseInt(num), avg, occurrences };
            }).filter(item => item.occurrences > 0);

            if (stats.length === 0) {
                container.innerHTML = `
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center; color: #666;">
                        <p>No hay suficientes datos para calcular esta estad√≠stica.</p>
                        <p style="font-size: 0.9em; margin-top: 10px;">Se necesitan m√°s tiradas donde los n√∫meros no salgan durante ${threshold} rolls consecutivos.</p>
                    </div>
                `;
                return;
            }

            stats.sort((a, b) => a.avg - b.avg);

            container.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; margin-bottom: 15px;">
                        ${stats.slice(0, 15).map(item => {
                            const color = item.num == 0 ? '#27ae60' : redNumbers.includes(item.num) ? '#e74c3c' : '#2c3e50';
                            return `
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 1.6em; font-weight: 700; color: ${color}; margin-bottom: 5px;">${item.num}</div>
                                    <div style="font-size: 1.1em; font-weight: 600; color: #333;">${item.avg.toFixed(1)} <small style="font-size: 0.7em;">rolls</small></div>
                                    <div style="font-size: 0.75em; color: #999; margin-top: 3px;">${item.occurrences} veces</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="padding: 15px; background: #f0f0f0; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #333;">Resumen:</strong><br>
                        <span style="color: #666; font-size: 0.95em;">
                            üìä Promedio general: <strong>${(stats.reduce((sum, item) => sum + item.avg, 0) / stats.length).toFixed(1)} rolls</strong><br>
                            üéØ N√∫meros analizados: <strong>${stats.length}</strong><br>
                            üìà Total de ocurrencias: <strong>${stats.reduce((sum, item) => sum + item.occurrences, 0)}</strong>
                        </span>
                    </div>
                </div>
            `;
        }

        function exportToExcel() {
            if (calculatedResults.length === 0) {
                alert('No hay resultados para exportar');
                return;
            }

            // Preparar datos seg√∫n el tipo de juego
            let excelData = [];
            const timestamp = new Date().toLocaleString('es-ES');
            const serverSeed = document.getElementById('serverSeed').value;
            const clientSeed = document.getElementById('clientSeed').value;

            switch(currentGame) {
                case 'roulette':
                    excelData = calculatedResults.map(r => ({
                        'Nonce': r.nonce,
                        'N√∫mero': r.value,
                        'Color': r.color,
                        'Par/Impar': r.value === 0 ? 'Verde' : (r.value % 2 === 0 ? 'Par' : 'Impar'),
                        'Alto/Bajo': r.value === 0 ? 'Verde' : (r.value <= 18 ? 'Bajo (1-18)' : 'Alto (19-36)'),
                        'Hash': r.hash
                    }));
                    break;

                case 'dice':
                    excelData = calculatedResults.map(r => ({
                        'Nonce': r.nonce,
                        'Resultado': r.value.toFixed(2),
                        'Bajo 50': r.value < 50 ? 'S√≠' : 'No',
                        'Rango': r.value < 25 ? '0-25' : r.value < 50 ? '25-50' : r.value < 75 ? '50-75' : '75-100',
                        'Hash': r.hash
                    }));
                    break;

                case 'limbo':
                    excelData = calculatedResults.map(r => ({
                        'Nonce': r.nonce,
                        'Multiplicador': r.value.toFixed(2) + 'x',
                        'Valor Num√©rico': r.value.toFixed(4),
                        'Categor√≠a': r.value < 2 ? '1-2x' : r.value < 5 ? '2-5x' : r.value < 10 ? '5-10x' : r.value < 50 ? '10-50x' : '50x+',
                        'Hash': r.hash
                    }));
                    break;

                case 'mines':
                    excelData = calculatedResults.map(r => ({
                        'Nonce': r.nonce,
                        'Posiciones Minas': r.display,
                        'Cantidad Minas': r.positions.length,
                        'Primera Mina': r.positions[0],
                        '√öltima Mina': r.positions[r.positions.length - 1],
                        'Hash': r.hash
                    }));
                    break;
            }

            // Crear hoja de informaci√≥n
            const infoData = [
                ['Informaci√≥n de Verificaci√≥n Provably Fair'],
                [''],
                ['Juego:', currentGame.toUpperCase()],
                ['Server Seed:', serverSeed],
                ['Client Seed:', clientSeed],
                ['Nonce Inicial:', document.getElementById('nonce').value],
                ['Total Tiradas:', calculatedResults.length],
                ['Fecha Exportaci√≥n:', timestamp],
                [''],
                ['Estad√≠sticas:']
            ];

            // Agregar estad√≠sticas espec√≠ficas
            const stats = calculateStats();
            stats.forEach(stat => {
                infoData.push([stat.label + ':', stat.value]);
            });

            // Crear libro de trabajo
            const wb = XLSX.utils.book_new();

            // Hoja de informaci√≥n
            const wsInfo = XLSX.utils.aoa_to_sheet(infoData);
            XLSX.utils.book_append_sheet(wb, wsInfo, 'Informaci√≥n');

            // Hoja de resultados
            const wsResults = XLSX.utils.json_to_sheet(excelData);
            
            // Ajustar ancho de columnas
            const maxWidth = 50;
            const wscols = Object.keys(excelData[0] || {}).map(key => {
                const maxLen = Math.max(
                    key.length,
                    ...excelData.map(row => (row[key] || '').toString().length)
                );
                return { wch: Math.min(maxLen + 2, maxWidth) };
            });
            wsResults['!cols'] = wscols;

            XLSX.utils.book_append_sheet(wb, wsResults, 'Resultados');

            // Si hay muchos resultados, crear hoja de resumen
            if (calculatedResults.length > 100) {
                let summaryData = [];
                
                if (currentGame === 'roulette') {
                    const distribution = {};
                    for (let i = 0; i <= 36; i++) distribution[i] = 0;
                    calculatedResults.forEach(r => distribution[r.value]++);
                    
                    summaryData = Object.entries(distribution).map(([num, count]) => ({
                        'N√∫mero': num,
                        'Frecuencia': count,
                        'Porcentaje': ((count / calculatedResults.length) * 100).toFixed(2) + '%'
                    }));
                } else if (currentGame === 'dice') {
                    for (let i = 0; i < 10; i++) {
                        const min = i * 10;
                        const max = (i + 1) * 10;
                        const count = calculatedResults.filter(r => r.value >= min && r.value < max).length;
                        summaryData.push({
                            'Rango': `${min}-${max}`,
                            'Frecuencia': count,
                            'Porcentaje': ((count / calculatedResults.length) * 100).toFixed(2) + '%'
                        });
                    }
                } else if (currentGame === 'limbo') {
                    const ranges = [
                        {label: '1-2x', min: 1, max: 2},
                        {label: '2-5x', min: 2, max: 5},
                        {label: '5-10x', min: 5, max: 10},
                        {label: '10-50x', min: 10, max: 50},
                        {label: '50x+', min: 50, max: Infinity}
                    ];
                    summaryData = ranges.map(range => {
                        const count = calculatedResults.filter(r => r.value >= range.min && r.value < range.max).length;
                        return {
                            'Rango': range.label,
                            'Frecuencia': count,
                            'Porcentaje': ((count / calculatedResults.length) * 100).toFixed(2) + '%'
                        };
                    });
                } else if (currentGame === 'mines') {
                    const positionFreq = {};
                    for (let i = 0; i < 25; i++) positionFreq[i] = 0;
                    calculatedResults.forEach(r => {
                        r.positions.forEach(pos => positionFreq[pos]++);
                    });
                    
                    summaryData = Object.entries(positionFreq).map(([pos, count]) => ({
                        'Posici√≥n': pos,
                        'Frecuencia': count,
                        'Porcentaje': ((count / (calculatedResults.length * parseInt(document.getElementById('minesCount').value))) * 100).toFixed(2) + '%'
                    }));
                }

                const wsSummary = XLSX.utils.json_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(wb, wsSummary, 'Resumen Estad√≠stico');
            }

            // Generar nombre de archivo
            const fileName = `Stake_${currentGame}_${serverSeed.substring(0, 8)}_${new Date().getTime()}.xlsx`;
            
            // Descargar archivo
            XLSX.writeFile(wb, fileName);
            
            // Mensaje de confirmaci√≥n
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                animation: slideIn 0.5s ease-out;
            `;
            notification.innerHTML = `
                <strong>‚úÖ Excel exportado exitosamente</strong><br>
                <small>${calculatedResults.length} resultados exportados</small>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }
    </script>
    <style>
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }
    </style>
</body>
</html>
