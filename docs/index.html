<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verificador Provably Fair - Stake</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            animation: fadeIn 0.8s ease-in;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            animation: slideUp 0.5s ease-out;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95em;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(255,255,255,0.15);
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .input-group input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #fff;
            background: rgba(255,255,255,0.25);
        }

        .input-group select option {
            background: #667eea;
            color: #fff;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .results {
            margin-top: 30px;
        }

        .result-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .result-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        .result-number {
            font-size: 1.3em;
            font-weight: 700;
        }

        .result-details {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .chart-container {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            display: none;
        }

        .chart-container.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
            display: none;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.15);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .info-tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            margin-left: 5px;
            color: rgba(255,255,255,0.7);
            font-size: 0.9em;
        }
        
        .info-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            white-space: normal;
            width: 250px;
            font-size: 0.85em;
            line-height: 1.4;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .info-tooltip:hover::before {
            content: '';
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0,0,0,0.9);
            z-index: 1000;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 1.8em;
            }
            
            #after130Container > div,
            #after160Container > div,
            #after190Container > div,
            #after220Container > div,
            #after400Container > div,
            #after450Container > div,
            #after500Container > div {
                padding: 15px !important;
            }
            
            #after130Container > div > div:first-child,
            #after160Container > div > div:first-child,
            #after190Container > div > div:first-child,
            #after220Container > div > div:first-child,
            #after400Container > div > div:first-child,
            #after450Container > div > div:first-child,
            #after500Container > div > div:first-child {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)) !important;
                gap: 8px !important;
            }
            
            #after130Container > div > div:first-child > div,
            #after160Container > div > div:first-child > div,
            #after190Container > div > div:first-child > div,
            #after220Container > div > div:first-child > div,
            #after400Container > div > div:first-child > div,
            #after450Container > div > div:first-child > div,
            #after500Container > div > div:first-child > div {
                padding: 8px !important;
            }
            
            #after130Container > div > div:first-child > div > div:first-child,
            #after160Container > div > div:first-child > div > div:first-child,
            #after190Container > div > div:first-child > div > div:first-child,
            #after220Container > div > div:first-child > div > div:first-child,
            #after400Container > div > div:first-child > div > div:first-child,
            #after450Container > div > div:first-child > div > div:first-child,
            #after500Container > div > div:first-child > div > div:first-child {
                font-size: 1.3em !important;
            }
            
            #after130Container > div > div:first-child > div > div:nth-child(2),
            #after160Container > div > div:first-child > div > div:nth-child(2),
            #after190Container > div > div:first-child > div > div:nth-child(2),
            #after220Container > div > div:first-child > div > div:nth-child(2),
            #after400Container > div > div:first-child > div > div:nth-child(2),
            #after450Container > div > div:first-child > div > div:nth-child(2),
            #after500Container > div > div:first-child > div > div:nth-child(2) {
                font-size: 0.95em !important;
            }
            
            #colorStatsContainer > div,
            #thirdStatsContainer > div {
                grid-template-columns: 1fr !important;
            }
            
            #topMultipliersContainer > div > div > div,
            #limboStreaksContainer > div,
            #diceExtremesContainer > div > div:last-child,
            #diceStreaksContainer > div {
                grid-template-columns: 1fr !important;
            }
            
            #maxStreaksContainer {
                grid-template-columns: 1fr !important;
            }
            
            #avgFrequencyContainer {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)) !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎲 Verificador Provably Fair</h1>
            <p>Verifica la justicia de tus tiradas en Stake.com</p>
        </div>

        <div class="card">
            <h2 style="margin-bottom: 20px;">⚙️ Configuración</h2>
            
            <div class="input-group">
                <label>Juego</label>
                <select id="gameType">
                    <option value="roulette">🎡 Roulette</option>
                    <option value="dice">🎲 Dice</option>
                    <option value="limbo">🚀 Limbo</option>
                    <option value="mines">💣 Mines</option>
                </select>
            </div>

            <div class="grid-2">
                <div class="input-group">
                    <label>Server Seed (Hash)</label>
                    <input type="text" id="serverSeed" placeholder="Ej: abc123...">
                </div>
                <div class="input-group">
                    <label>Client Seed</label>
                    <input type="text" id="clientSeed" placeholder="Ej: xyz789...">
                </div>
            </div>

            <div class="grid-2">
                <div class="input-group">
                    <label>Nonce Inicial</label>
                    <input type="number" id="nonce" value="0" min="0">
                </div>
                <div class="input-group">
                    <label>Número de Tiradas</label>
                    <input type="number" id="rounds" value="100" min="1" max="1000000">
                </div>
            </div>

            <div id="minesConfig" style="display: none;">
                <div class="input-group">
                    <label>Número de Minas</label>
                    <input type="number" id="minesCount" value="3" min="1" max="24">
                </div>
            </div>

            <button class="btn" onclick="calculate()">🔍 Calcular Resultados</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Calculando resultados...</p>
        </div>

        <div class="card" id="resultsCard" style="display: none;">
            <h2 style="margin-bottom: 20px;">📊 Resultados</h2>
            
            <div class="stats" id="stats"></div>

            <div class="results" id="results"></div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
                <button class="btn" onclick="showCharts()">📈 Ver Gráficos</button>
                <button class="btn" onclick="exportToExcel()" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);">📊 Exportar a Excel</button>
            </div>
        </div>

        <div class="chart-container" id="chartContainer">
            <canvas id="resultChart"></canvas>
            
            <div id="rouletteStats" style="display: none; margin-top: 30px;">
                <h3 style="color: #333; margin-bottom: 20px; font-size: 1.5em;">📊 Análisis Avanzado de Ruleta</h3>
                
                <div style="background: linear-gradient(135deg, #134e5e 0%, #71b280 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        📊 Frecuencia de Rachas Consecutivas
                        <span class="info-tooltip" data-tooltip="Muestra cuántas veces un número cualquiera alcanzó exactamente X tiradas sin salir. Estas estadísticas NO son acumulativas.">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 20px; font-size: 0.95em;">
                        Cuántas veces un número cualquiera no sale durante X tiradas consecutivas<br>
                        <strong>Nota:</strong> Cada contador es independiente (no acumulativo)
                    </p>
                    <div id="streakFrequencyContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;"></div>
                </div>

                <div style="background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        🔥 Rachas Máximas sin Salir
                        <span class="info-tooltip" data-tooltip="Muestra el mayor número de tiradas consecutivas que cada número estuvo sin aparecer durante toda la sesión de juego.">ⓘ</span>
                    </h4>
                    <div id="maxStreaksContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;"></div>
                </div>

                <div style="background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        📈 Frecuencia Media de Aparición
                        <span class="info-tooltip" data-tooltip="Promedio de tiradas entre cada aparición del número. Un valor más bajo indica que el número apareció con más frecuencia.">ⓘ</span>
                    </h4>
                    <div id="avgFrequencyContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;"></div>
                </div>

                <div style="background: linear-gradient(135deg, #16a085 0%, #f4d03f 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        ⏱️ Media Aparición tras 130 Tiradas sin Salir
                        <span class="info-tooltip" data-tooltip="Cuando un número alcanza exactamente 130 tiradas sin salir, este dato muestra cuántas tiradas adicionales tardó en aparecer (promedio).">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Promedio de tiradas adicionales hasta que aparece el número
                    </p>
                    <div id="after130Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #2980b9 0%, #6dd5fa 50%, #2c3e50 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        ⏱️ Media Aparición tras 160 Tiradas sin Salir
                        <span class="info-tooltip" data-tooltip="Cuando un número alcanza exactamente 160 tiradas sin salir, este dato muestra cuántas tiradas adicionales tardó en aparecer (promedio).">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Promedio de tiradas adicionales hasta que aparece el número
                    </p>
                    <div id="after160Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        ⏱️ Media Aparición tras 190 Tiradas sin Salir
                        <span class="info-tooltip" data-tooltip="Cuando un número alcanza exactamente 190 tiradas sin salir, este dato muestra cuántas tiradas adicionales tardó en aparecer (promedio).">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Promedio de tiradas adicionales hasta que aparece el número
                    </p>
                    <div id="after190Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #134e5e 0%, #71b280 100%); padding: 25px; border-radius: 15px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        ⏱️ Media Aparición tras 220 Tiradas sin Salir
                        <span class="info-tooltip" data-tooltip="Cuando un número alcanza exactamente 220 tiradas sin salir, este dato muestra cuántas tiradas adicionales tardó en aparecer (promedio).">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Promedio de tiradas adicionales hasta que aparece el número
                    </p>
                    <div id="after220Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%); padding: 25px; border-radius: 15px; margin-top: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        ⏱️ Media Aparición tras 400 Tiradas sin Salir
                        <span class="info-tooltip" data-tooltip="Cuando un número alcanza exactamente 400 tiradas sin salir, este dato muestra cuántas tiradas adicionales tardó en aparecer (promedio).">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Promedio de tiradas adicionales hasta que aparece el número
                    </p>
                    <div id="after400Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); padding: 25px; border-radius: 15px; margin-top: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        ⏱️ Media Aparición tras 450 Tiradas sin Salir
                        <span class="info-tooltip" data-tooltip="Cuando un número alcanza exactamente 450 tiradas sin salir, este dato muestra cuántas tiradas adicionales tardó en aparecer (promedio).">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Promedio de tiradas adicionales hasta que aparece el número
                    </p>
                    <div id="after450Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%); padding: 25px; border-radius: 15px; margin-top: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        ⏱️ Media Aparición tras 500 Tiradas sin Salir
                        <span class="info-tooltip" data-tooltip="Cuando un número alcanza exactamente 500 tiradas sin salir, este dato muestra cuántas tiradas adicionales tardó en aparecer (promedio).">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Promedio de tiradas adicionales hasta que aparece el número
                    </p>
                    <div id="after500Container"></div>
                </div>

                <div style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); padding: 25px; border-radius: 15px; margin-top: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        🎨 Estadísticas de Colores
                        <span class="info-tooltip" data-tooltip="Analiza la frecuencia y rachas de colores (rojo, negro, verde). Muestra cuántas veces cada color apareció consecutivamente y cuánto tiempo estuvo sin aparecer.">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        <strong>Nota:</strong> Estas estadísticas muestran rachas consecutivas independientes (no acumulativas)
                    </p>
                    <div id="colorStatsContainer"></div>
                </div>

                <div style="background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); padding: 25px; border-radius: 15px; margin-top: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        🔢 Estadísticas de Tercios
                        <span class="info-tooltip" data-tooltip="Divide la ruleta en tres tercios (1-12, 13-24, 25-36) y analiza la frecuencia y rachas de cada sección.">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Primer tercio (1-12) | Segundo tercio (13-24) | Tercer tercio (25-36)
                    </p>
                    <div id="thirdStatsContainer"></div>
                </div>
            </div>

            <div id="limboStats" style="display: none; margin-top: 30px;">
                <h3 style="color: #333; margin-bottom: 20px; font-size: 1.5em;">🚀 Análisis Avanzado de Limbo</h3>
                
                <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        🏆 Top 10 Multiplicadores Más Altos
                        <span class="info-tooltip" data-tooltip="Los 10 multiplicadores más altos obtenidos durante toda la sesión, mostrando en qué tirada (nonce) ocurrieron.">ⓘ</span>
                    </h4>
                    <div id="topMultipliersContainer"></div>
                </div>

                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 25px; border-radius: 15px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        ⏱️ Tiradas sin Multiplicadores Altos
                        <span class="info-tooltip" data-tooltip="Muestra el máximo número de tiradas consecutivas sin alcanzar cada umbral de multiplicador. Útil para entender la frecuencia de multiplicadores altos.">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Máximas rachas consecutivas sin alcanzar estos multiplicadores
                    </p>
                    <div id="limboStreaksContainer"></div>
                </div>
            </div>

            <div id="diceStats" style="display: none; margin-top: 30px;">
                <h3 style="color: #333; margin-bottom: 20px; font-size: 1.5em;">🎲 Análisis Avanzado de Dice</h3>
                
                <div style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); padding: 25px; border-radius: 15px; margin-bottom: 20px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        📊 Resultados Extremos
                        <span class="info-tooltip" data-tooltip="Muestra la frecuencia de resultados muy bajos y muy altos, que corresponden a multiplicadores de 100x, 250x, 500x y 1000x.">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Frecuencia de valores muy bajos y muy altos (multiplicadores altos)
                    </p>
                    <div id="diceExtremesContainer"></div>
                </div>

                <div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); padding: 25px; border-radius: 15px;">
                    <h4 style="color: white; margin-bottom: 15px; font-size: 1.2em;">
                        🔥 Rachas sin Extremos
                        <span class="info-tooltip" data-tooltip="Máximas tiradas consecutivas sin obtener resultados extremos (≤1 o ≥99), que representan multiplicadores de 100x.">ⓘ</span>
                    </h4>
                    <p style="color: white; opacity: 0.9; margin-bottom: 15px; font-size: 0.9em;">
                        Máximas tiradas consecutivas sin resultados extremos
                    </p>
                    <div id="diceStreaksContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let calculatedResults = [];
        let currentGame = 'roulette';

        document.getElementById('gameType').addEventListener('change', function() {
            currentGame = this.value;
            document.getElementById('minesConfig').style.display = 
                currentGame === 'mines' ? 'block' : 'none';
        });

        function byteGenerator(serverSeed, clientSeed, nonce, cursor) {
            let currentRound = cursor;
            let currentRoundCursor = 0;
            
            return {
                next: function() {
                    if (currentRoundCursor === 32) {
                        currentRoundCursor = 0;
                        currentRound += 1;
                    }
                    const hmac = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:${currentRound}`, serverSeed);
                    const buffer = hmac.toString(CryptoJS.enc.Hex);
                    const byte = parseInt(buffer.substring(currentRoundCursor * 2, currentRoundCursor * 2 + 2), 16);
                    currentRoundCursor += 1;
                    return { value: byte };
                }
            };
        }

        function generateFloats(serverSeed, clientSeed, nonce, cursor, count) {
            const rng = byteGenerator(serverSeed, clientSeed, nonce, cursor);
            const bytes = [];
            
            while (bytes.length < count * 4) {
                bytes.push(rng.next().value);
            }
            
            const floats = [];
            for (let i = 0; i < count; i++) {
                const chunk = bytes.slice(i * 4, i * 4 + 4);
                let result = 0;
                for (let j = 0; j < 4; j++) {
                    const divider = Math.pow(256, j + 1);
                    result += chunk[j] / divider;
                }
                floats.push(result);
            }
            
            return floats;
        }

        function generateResult(serverSeed, clientSeed, nonce, game, minesCount = 3) {
            switch(game) {
                case 'roulette':
                    return calculateRoulette(serverSeed, clientSeed, nonce);
                case 'dice':
                    return calculateDice(serverSeed, clientSeed, nonce);
                case 'limbo':
                    return calculateLimbo(serverSeed, clientSeed, nonce);
                case 'mines':
                    return calculateMines(serverSeed, clientSeed, nonce, minesCount);
                default:
                    return null;
            }
        }

        function calculateRoulette(serverSeed, clientSeed, nonce) {
            const floats = generateFloats(serverSeed, clientSeed, nonce, 0, 1);
            const result = Math.floor(floats[0] * 37);
            
            let color = 'verde';
            if (result !== 0) {
                const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
                color = redNumbers.includes(result) ? 'rojo' : 'negro';
            }
            
            const hash = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:0`, serverSeed).toString().substring(0, 8);
            
            return {
                value: result,
                display: result,
                color: color,
                hash: hash
            };
        }

        function calculateDice(serverSeed, clientSeed, nonce) {
            const floats = generateFloats(serverSeed, clientSeed, nonce, 0, 1);
            const result = (floats[0] * 10001) / 100;
            
            const hash = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:0`, serverSeed).toString().substring(0, 8);
            
            return {
                value: result,
                display: result.toFixed(2),
                hash: hash
            };
        }

        function calculateLimbo(serverSeed, clientSeed, nonce) {
            const floats = generateFloats(serverSeed, clientSeed, nonce, 0, 1);
            const houseEdge = 0.99;
            
            const floatPoint = (1e8 / (floats[0] * 1e8)) * houseEdge;
            const result = Math.max(1, Math.floor(floatPoint * 100) / 100);
            
            const hash = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:0`, serverSeed).toString().substring(0, 8);
            
            return {
                value: result,
                display: result.toFixed(2) + 'x',
                hash: hash
            };
        }

        function calculateMines(serverSeed, clientSeed, nonce, minesCount) {
            const gridSize = 25;
            const floats = generateFloats(serverSeed, clientSeed, nonce, 0, minesCount);
            const positions = [];
            
            const deck = Array.from({length: gridSize}, (_, i) => i);
            
            for (let i = 0; i < minesCount; i++) {
                const index = Math.floor(floats[i] * deck.length);
                positions.push(deck[index]);
                deck.splice(index, 1);
            }
            
            positions.sort((a, b) => a - b);
            
            const hash = CryptoJS.HmacSHA256(`${clientSeed}:${nonce}:0`, serverSeed).toString().substring(0, 8);
            
            return {
                value: positions,
                display: positions.join(', '),
                hash: hash,
                positions: positions
            };
        }

        async function calculate() {
            const serverSeed = document.getElementById('serverSeed').value.trim();
            const clientSeed = document.getElementById('clientSeed').value.trim();
            const startNonce = parseInt(document.getElementById('nonce').value);
            const rounds = parseInt(document.getElementById('rounds').value);
            const minesCount = parseInt(document.getElementById('minesCount').value);

            if (!serverSeed || !clientSeed) {
                alert('Por favor ingresa ambas seeds');
                return;
            }

            if (rounds > 1000000) {
                alert('Máximo 1,000,000 de tiradas');
                return;
            }

            if (rounds > 50000) {
                if (!confirm(`Vas a calcular ${rounds.toLocaleString()} tiradas. Esto puede tomar algunos segundos. ¿Continuar?`)) {
                    return;
                }
            }

            document.getElementById('loading').classList.add('active');
            document.getElementById('resultsCard').style.display = 'none';
            document.getElementById('chartContainer').classList.remove('active');
            
            calculatedResults = [];

            const chunkSize = 1000;
            let processed = 0;

            async function processChunk() {
                const end = Math.min(processed + chunkSize, rounds);
                
                for (let i = processed; i < end; i++) {
                    const result = generateResult(serverSeed, clientSeed, startNonce + i, currentGame, minesCount);
                    calculatedResults.push({
                        nonce: startNonce + i,
                        ...result
                    });
                }
                
                processed = end;
                
                const progress = ((processed / rounds) * 100).toFixed(1);
                document.getElementById('loading').innerHTML = `
                    <div class="spinner"></div>
                    <p>Calculando resultados... ${progress}%</p>
                    <p style="opacity: 0.7; font-size: 0.9em;">${processed.toLocaleString()} / ${rounds.toLocaleString()} tiradas</p>
                `;
                
                if (processed < rounds) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                    await processChunk();
                }
            }

            await processChunk();

            displayResults();
            document.getElementById('loading').classList.remove('active');
            document.getElementById('resultsCard').style.display = 'block';
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            const statsDiv = document.getElementById('stats');
            
            const stats = calculateStats();
            statsDiv.innerHTML = `
                ${stats.map(stat => `
                    <div class="stat-card">
                        <div class="stat-value">${stat.value}</div>
                        <div class="stat-label">${stat.label}</div>
                    </div>
                `).join('')}
            `;

            const displayLimit = Math.min(50, calculatedResults.length);
            resultsDiv.innerHTML = `
                <h3 style="margin-bottom: 15px;">Primeros ${displayLimit} resultados:</h3>
                ${calculatedResults.slice(0, displayLimit).map(r => `
                    <div class="result-item">
                        <div>
                            <span class="result-number">${r.display}</span>
                            ${r.color ? `<span style="margin-left: 10px; padding: 5px 10px; background: ${r.color === 'rojo' ? '#e74c3c' : r.color === 'negro' ? '#2c3e50' : '#27ae60'}; border-radius: 5px;">${r.color}</span>` : ''}
                        </div>
                        <div class="result-details">
                            Nonce: ${r.nonce} | Hash: ${r.hash}
                        </div>
                    </div>
                `).join('')}
                ${calculatedResults.length > displayLimit ? `<p style="text-align: center; margin-top: 20px; opacity: 0.8;">... y ${calculatedResults.length - displayLimit} resultados más</p>` : ''}
            `;
        }

        function calculateStats() {
            const total = calculatedResults.length;
            
            switch(currentGame) {
                case 'roulette':
                    const reds = calculatedResults.filter(r => r.color === 'rojo').length;
                    const blacks = calculatedResults.filter(r => r.color === 'negro').length;
                    const greens = calculatedResults.filter(r => r.color === 'verde').length;
                    return [
                        { label: 'Total Tiradas', value: total },
                        { label: 'Rojos', value: reds + ` (${(reds/total*100).toFixed(1)}%)` },
                        { label: 'Negros', value: blacks + ` (${(blacks/total*100).toFixed(1)}%)` },
                        { label: 'Verdes', value: greens + ` (${(greens/total*100).toFixed(1)}%)` }
                    ];
                
                case 'dice':
                    const avg = calculatedResults.reduce((sum, r) => sum + r.value, 0) / total;
                    const under50 = calculatedResults.filter(r => r.value < 50).length;
                    return [
                        { label: 'Total Tiradas', value: total },
                        { label: 'Promedio', value: avg.toFixed(2) },
                        { label: 'Bajo 50', value: under50 + ` (${(under50/total*100).toFixed(1)}%)` },
                        { label: 'Sobre 50', value: (total-under50) + ` (${((total-under50)/total*100).toFixed(1)}%)` }
                    ];
                
                case 'limbo':
                    const avgMultiplier = calculatedResults.reduce((sum, r) => sum + r.value, 0) / total;
                    const over2x = calculatedResults.filter(r => r.value >= 2).length;
                    const over10x = calculatedResults.filter(r => r.value >= 10).length;
                    return [
                        { label: 'Total Tiradas', value: total },
                        { label: 'Promedio', value: avgMultiplier.toFixed(2) + 'x' },
                        { label: 'Sobre 2x', value: over2x + ` (${(over2x/total*100).toFixed(1)}%)` },
                        { label: 'Sobre 10x', value: over10x + ` (${(over10x/total*100).toFixed(1)}%)` }
                    ];
                
                case 'mines':
                    return [
                        { label: 'Total Tiradas', value: total },
                        { label: 'Minas por Juego', value: document.getElementById('minesCount').value },
                        { label: 'Casillas Totales', value: '25' },
                        { label: 'Configuraciones', value: total }
                    ];
            }
        }

        function showCharts() {
            const chartContainer = document.getElementById('chartContainer');
            
            const loadingChart = document.createElement('div');
            loadingChart.id = 'chartLoading';
            loadingChart.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 40px 60px;
                border-radius: 20px;
                z-index: 10000;
                text-align: center;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            loadingChart.innerHTML = `
                <div class="spinner"></div>
                <p style="margin-top: 20px; font-size: 1.2em; font-weight: 600;">Generando gráficos...</p>
                <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">Esto puede tardar unos segundos</p>
            `;
            document.body.appendChild(loadingChart);
            
            setTimeout(() => {
                chartContainer.classList.add('active');
                
                const ctx = document.getElementById('resultChart').getContext('2d');
                
                if (window.myChart) {
                    window.myChart.destroy();
                }

                let chartData = prepareChartData();
                
                window.myChart = new Chart(ctx, {
                    type: chartData.type,
                    data: chartData.data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: true,
                                labels: { color: '#333', font: { size: 14 } }
                            },
                            title: {
                                display: true,
                                text: chartData.title,
                                color: '#333',
                                font: { size: 18, weight: 'bold' }
                            }
                        },
                        scales: chartData.scales
                    }
                });

                document.getElementById('rouletteStats').style.display = 'none';
                document.getElementById('limboStats').style.display = 'none';
                document.getElementById('diceStats').style.display = 'none';

                if (currentGame === 'roulette') {
                    document.getElementById('rouletteStats').style.display = 'block';
                    calculateRouletteAdvancedStats();
                } else if (currentGame === 'limbo') {
                    document.getElementById('limboStats').style.display = 'block';
                    calculateLimboAdvancedStats();
                } else if (currentGame === 'dice') {
                    document.getElementById('diceStats').style.display = 'block';
                    calculateDiceAdvancedStats();
                }

                loadingChart.remove();
                
                chartContainer.scrollIntoView({ behavior: 'smooth' });
            }, 100);
        }

        function prepareChartData() {
            switch(currentGame) {
                case 'roulette':
                    const distribution = {};
                    for (let i = 0; i <= 36; i++) distribution[i] = 0;
                    calculatedResults.forEach(r => distribution[r.value]++);
                    
                    return {
                        type: 'bar',
                        title: 'Distribución de Números en Roulette',
                        data: {
                            labels: Object.keys(distribution),
                            datasets: [{
                                label: 'Frecuencia',
                                data: Object.values(distribution),
                                backgroundColor: Object.keys(distribution).map(n => {
                                    if (n == 0) return '#27ae60';
                                    const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
                                    return redNumbers.includes(parseInt(n)) ? '#e74c3c' : '#2c3e50';
                                })
                            }]
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#333' }
                            },
                            x: { 
                                ticks: { color: '#333' }
                            }
                        }
                    };
                
                case 'dice':
                    const bins = 10;
                    const binCounts = new Array(bins).fill(0);
                    calculatedResults.forEach(r => {
                        const bin = Math.min(Math.floor(r.value / 10), bins - 1);
                        binCounts[bin]++;
                    });
                    
                    return {
                        type: 'bar',
                        title: 'Distribución de Resultados en Dice',
                        data: {
                            labels: Array.from({length: bins}, (_, i) => `${i*10}-${(i+1)*10}`),
                            datasets: [{
                                label: 'Frecuencia',
                                data: binCounts,
                                backgroundColor: '#3498db'
                            }]
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#333' }
                            },
                            x: { 
                                ticks: { color: '#333' }
                            }
                        }
                    };
                
                case 'limbo':
                    const ranges = [
                        {label: '1-2x', min: 1, max: 2},
                        {label: '2-5x', min: 2, max: 5},
                        {label: '5-10x', min: 5, max: 10},
                        {label: '10-50x', min: 10, max: 50},
                        {label: '50x+', min: 50, max: Infinity}
                    ];
                    const rangeCounts = ranges.map(range => 
                        calculatedResults.filter(r => r.value >= range.min && r.value < range.max).length
                    );
                    
                    return {
                        type: 'pie',
                        title: 'Distribución de Multiplicadores en Limbo',
                        data: {
                            labels: ranges.map(r => r.label),
                            datasets: [{
                                data: rangeCounts,
                                backgroundColor: ['#3498db', '#9b59b6', '#e74c3c', '#f39c12', '#27ae60']
                            }]
                        },
                        scales: {}
                    };
                
                case 'mines':
                    const positionFreq = new Array(25).fill(0);
                    calculatedResults.forEach(r => {
                        r.positions.forEach(pos => positionFreq[pos]++);
                    });
                    
                    return {
                        type: 'bar',
                        title: 'Frecuencia de Minas por Posición',
                        data: {
                            labels: Array.from({length: 25}, (_, i) => i.toString()),
                            datasets: [{
                                label: 'Frecuencia',
                                data: positionFreq,
                                backgroundColor: '#e74c3c'
                            }]
                        },
                        scales: {
                            y: { 
                                beginAtZero: true,
                                ticks: { color: '#333' }
                            },
                            x: { 
                                ticks: { color: '#333' }
                            }
                        }
                    };
            }
        }

        function calculateRouletteAdvancedStats() {
            const streakThresholds = [130, 160, 190, 220, 300, 350];
            const streakCounts = {};
            streakThresholds.forEach(t => streakCounts[t] = 0);
            
            for (let num = 0; num <= 36; num++) {
                let streak = 0;
                
                calculatedResults.forEach((result, index) => {
                    if (result.value !== num) {
                        streak++;
                        
                        streakThresholds.forEach(threshold => {
                            if (streak === threshold) {
                                streakCounts[threshold]++;
                            }
                        });
                    } else {
                        streak = 0;
                    }
                });
            }
            
            const maxStreaks = {};
            const lastSeen = {};
            const currentStreak = {};
            
            for (let num = 0; num <= 36; num++) {
                maxStreaks[num] = { streak: 0, startNonce: 0, endNonce: 0 };
                currentStreak[num] = { count: 0, startNonce: 0 };
                lastSeen[num] = -1;
            }
            
            calculatedResults.forEach((result, index) => {
                const num = result.value;
                
                for (let n = 0; n <= 36; n++) {
                    if (n !== num) {
                        if (currentStreak[n].count === 0) {
                            currentStreak[n].startNonce = result.nonce;
                        }
                        currentStreak[n].count++;
                        
                        if (currentStreak[n].count > maxStreaks[n].streak) {
                            maxStreaks[n] = {
                                streak: currentStreak[n].count,
                                startNonce: currentStreak[n].startNonce,
                                endNonce: result.nonce
                            };
                        }
                    } else {
                        currentStreak[n] = { count: 0, startNonce: 0 };
                        lastSeen[n] = index;
                    }
                }
            });

            const appearances = {};
            for (let num = 0; num <= 36; num++) {
                appearances[num] = [];
            }
            
            calculatedResults.forEach((result, index) => {
                appearances[result.value].push(index);
            });

            const avgFrequency = {};
            for (let num = 0; num <= 36; num++) {
                if (appearances[num].length > 1) {
                    const intervals = [];
                    for (let i = 1; i < appearances[num].length; i++) {
                        intervals.push(appearances[num][i] - appearances[num][i - 1]);
                    }
                    avgFrequency[num] = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                } else {
                    avgFrequency[num] = appearances[num].length === 1 ? calculatedResults.length : 0;
                }
            }

            const thresholds = [130, 160, 190, 220, 400, 450, 500];
            const afterThreshold = {};
            
            thresholds.forEach(threshold => {
                afterThreshold[threshold] = {};
                for (let num = 0; num <= 36; num++) {
                    afterThreshold[threshold][num] = [];
                }
            });

            for (let num = 0; num <= 36; num++) {
                let streak = 0;
                let streakStart = 0;
                
                calculatedResults.forEach((result, index) => {
                    if (result.value !== num) {
                        if (streak === 0) streakStart = index;
                        streak++;
                        
                        thresholds.forEach(threshold => {
                            if (streak === threshold) {
                                for (let j = index + 1; j < calculatedResults.length; j++) {
                                    if (calculatedResults[j].value === num) {
                                        afterThreshold[threshold][num].push(j - index);
                                        break;
                                    }
                                }
                            }
                        });
                    } else {
                        streak = 0;
                    }
                });
            }

            const colorStats = calculateColorStats();
            const thirdStats = calculateThirdStats();

            displayStreakFrequency(streakCounts);
            displayMaxStreaks(maxStreaks);
            displayAvgFrequency(avgFrequency);
            displayAfterThreshold(afterThreshold, 130, 'after130Container');
            displayAfterThreshold(afterThreshold, 160, 'after160Container');
            displayAfterThreshold(afterThreshold, 190, 'after190Container');
            displayAfterThreshold(afterThreshold, 220, 'after220Container');
            displayAfterThreshold(afterThreshold, 400, 'after400Container');
            displayAfterThreshold(afterThreshold, 450, 'after450Container');
            displayAfterThreshold(afterThreshold, 500, 'after500Container');
            displayColorStats(colorStats);
            displayThirdStats(thirdStats);
        }

        function displayStreakFrequency(streakCounts) {
            const container = document.getElementById('streakFrequencyContainer');
            
            const entries = Object.entries(streakCounts).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
            
            container.innerHTML = entries.map(([threshold, count]) => `
                <div style="background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); text-align: center; transition: transform 0.3s ease;">
                    <div style="font-size: 2.5em; font-weight: 700; color: #134e5e; margin-bottom: 8px;">${count}</div>
                    <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">veces ocurrió</div>
                    <div style="font-size: 1.1em; font-weight: 600; color: #2c3e50;">
                        Racha de <span style="color: #e74c3c;">${threshold}</span> tiradas
                    </div>
                </div>
            `).join('');
        }

        function displayMaxStreaks(maxStreaks) {
            const container = document.getElementById('maxStreaksContainer');
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            
            const sorted = Object.entries(maxStreaks).sort((a, b) => b[1].streak - a[1].streak);
            
            container.innerHTML = sorted.slice(0, 10).map(([num, data]) => {
                const color = num == 0 ? '#27ae60' : redNumbers.includes(parseInt(num)) ? '#e74c3c' : '#2c3e50';
                return `
                    <div style="background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                            <span style="font-size: 1.8em; font-weight: 700; color: ${color};">${num}</span>
                            <span style="font-size: 1.5em; font-weight: 700; color: #e74c3c;">${data.streak}</span>
                        </div>
                        <div style="font-size: 0.85em; color: #666;">
                            <strong>Tiradas sin salir</strong><br>
                            Nonces: ${data.startNonce} → ${data.endNonce}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function displayAvgFrequency(avgFrequency) {
            const container = document.getElementById('avgFrequencyContainer');
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            
            container.innerHTML = Object.entries(avgFrequency).map(([num, freq]) => {
                const color = num == 0 ? '#27ae60' : redNumbers.includes(parseInt(num)) ? '#e74c3c' : '#2c3e50';
                return `
                    <div style="background: white; padding: 12px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: space-between;">
                        <span style="font-size: 1.4em; font-weight: 700; color: ${color};">${num}</span>
                        <span style="font-size: 1.2em; font-weight: 600; color: #333;">${freq > 0 ? freq.toFixed(1) : 'N/A'} <small style="font-size: 0.7em; opacity: 0.7;">rolls</small></span>
                    </div>
                `;
            }).join('');
        }

        function displayAfterThreshold(afterThreshold, threshold, containerId) {
            const container = document.getElementById(containerId);
            const data = afterThreshold[threshold];
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            
            const stats = Object.entries(data).map(([num, values]) => {
                const avg = values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
                const occurrences = values.length;
                return { num: parseInt(num), avg, occurrences };
            }).filter(item => item.occurrences > 0);

            if (stats.length === 0) {
                container.innerHTML = `
                    <div style="background: white; padding: 20px; border-radius: 10px; text-align: center; color: #666;">
                        <p>No hay suficientes datos para calcular esta estadística.</p>
                        <p style="font-size: 0.9em; margin-top: 10px;">Se necesitan más tiradas donde los números no salgan durante ${threshold} rolls consecutivos.</p>
                    </div>
                `;
                return;
            }

            stats.sort((a, b) => a.avg - b.avg);

            container.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; margin-bottom: 15px;">
                        ${stats.slice(0, 15).map(item => {
                            const color = item.num == 0 ? '#27ae60' : redNumbers.includes(item.num) ? '#e74c3c' : '#2c3e50';
                            return `
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 1.6em; font-weight: 700; color: ${color}; margin-bottom: 5px;">${item.num}</div>
                                    <div style="font-size: 1.1em; font-weight: 600; color: #333;">${item.avg.toFixed(1)} <small style="font-size: 0.7em;">rolls</small></div>
                                    <div style="font-size: 0.75em; color: #999; margin-top: 3px;">${item.occurrences}x</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="padding: 15px; background: #f0f0f0; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #333;">Resumen:</strong><br>
                        <span style="color: #666; font-size: 0.95em;">
                            📊 Promedio general: <strong>${(stats.reduce((sum, item) => sum + item.avg, 0) / stats.length).toFixed(1)} rolls</strong><br>
                            🎯 Números analizados: <strong>${stats.length}</strong><br>
                            📈 Total de ocurrencias: <strong>${stats.reduce((sum, item) => sum + item.occurrences, 0)}</strong>
                        </span>
                    </div>
                </div>
            `;
        }

        function calculateColorStats() {
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            
            const colorCounts = { rojo: 0, negro: 0, verde: 0 };
            calculatedResults.forEach(r => {
                colorCounts[r.color]++;
            });

            const maxStreaks = { rojo: 0, negro: 0, verde: 0 };
            const maxNoStreaks = { rojo: 0, negro: 0, verde: 0 };
            
            let currentStreaks = { rojo: 0, negro: 0, verde: 0 };
            let currentNoStreaks = { rojo: 0, negro: 0, verde: 0 };

            calculatedResults.forEach(r => {
                const color = r.color;
                
                currentStreaks[color]++;
                maxStreaks[color] = Math.max(maxStreaks[color], currentStreaks[color]);
                
                ['rojo', 'negro', 'verde'].forEach(c => {
                    if (c !== color) {
                        currentStreaks[c] = 0;
                        currentNoStreaks[c]++;
                        maxNoStreaks[c] = Math.max(maxNoStreaks[c], currentNoStreaks[c]);
                    } else {
                        currentNoStreaks[c] = 0;
                    }
                });
            });

            return {
                counts: colorCounts,
                maxStreaks,
                maxNoStreaks
            };
        }

        function calculateThirdStats() {
            const thirdCounts = { first: 0, second: 0, third: 0, zero: 0 };
            
            calculatedResults.forEach(r => {
                if (r.value === 0) {
                    thirdCounts.zero++;
                } else if (r.value <= 12) {
                    thirdCounts.first++;
                } else if (r.value <= 24) {
                    thirdCounts.second++;
                } else {
                    thirdCounts.third++;
                }
            });

            const maxStreaks = { first: 0, second: 0, third: 0, zero: 0 };
            const maxNoStreaks = { first: 0, second: 0, third: 0, zero: 0 };
            
            let currentStreaks = { first: 0, second: 0, third: 0, zero: 0 };
            let currentNoStreaks = { first: 0, second: 0, third: 0, zero: 0 };

            calculatedResults.forEach(r => {
                let third;
                if (r.value === 0) third = 'zero';
                else if (r.value <= 12) third = 'first';
                else if (r.value <= 24) third = 'second';
                else third = 'third';
                
                currentStreaks[third]++;
                maxStreaks[third] = Math.max(maxStreaks[third], currentStreaks[third]);
                
                ['first', 'second', 'third', 'zero'].forEach(t => {
                    if (t !== third) {
                        currentStreaks[t] = 0;
                        currentNoStreaks[t]++;
                        maxNoStreaks[t] = Math.max(maxNoStreaks[t], currentNoStreaks[t]);
                    } else {
                        currentNoStreaks[t] = 0;
                    }
                });
            });

            return {
                counts: thirdCounts,
                maxStreaks,
                maxNoStreaks
            };
        }

        function displayColorStats(colorStats) {
            const container = document.getElementById('colorStatsContainer');
            const total = calculatedResults.length;
            
            const colorData = [
                { name: 'Rojo', key: 'rojo', color: '#e74c3c' },
                { name: 'Negro', key: 'negro', color: '#2c3e50' },
                { name: 'Verde (0)', key: 'verde', color: '#27ae60' }
            ];

            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                    ${colorData.map(c => `
                        <div style="background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.15);">
                            <div style="text-align: center; margin-bottom: 15px;">
                                <div style="width: 60px; height: 60px; background: ${c.color}; border-radius: 50%; margin: 0 auto 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);"></div>
                                <h4 style="color: ${c.color}; font-size: 1.4em; margin-bottom: 5px;">${c.name}</h4>
                            </div>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 10px;">
                                <div style="color: #333; font-size: 0.9em; margin-bottom: 8px;">
                                    <strong>Total:</strong> ${colorStats.counts[c.key]} 
                                    <span style="color: #666;">(${(colorStats.counts[c.key]/total*100).toFixed(1)}%)</span>
                                </div>
                                <div style="color: #333; font-size: 0.9em; margin-bottom: 8px;">
                                    <strong>🔥 Máx. racha:</strong> ${colorStats.maxStreaks[c.key]} veces
                                </div>
                                <div style="color: #333; font-size: 0.9em;">
                                    <strong>❄️ Máx. sin salir:</strong> ${colorStats.maxNoStreaks[c.key]} veces
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function displayThirdStats(thirdStats) {
            const container = document.getElementById('thirdStatsContainer');
            const total = calculatedResults.length;
            
            const thirdData = [
                { name: '1º Tercio (1-12)', key: 'first', color: '#3498db' },
                { name: '2º Tercio (13-24)', key: 'second', color: '#9b59b6' },
                { name: '3º Tercio (25-36)', key: 'third', color: '#e67e22' },
                { name: 'Cero', key: 'zero', color: '#27ae60' }
            ];

            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 20px;">
                    ${thirdData.map(t => `
                        <div style="background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.15);">
                            <div style="text-align: center; margin-bottom: 15px;">
                                <div style="background: ${t.color}; color: white; padding: 12px; border-radius: 10px; font-weight: 700; font-size: 1.1em; margin-bottom: 10px;">
                                    ${t.name}
                                </div>
                            </div>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                                <div style="color: #333; font-size: 0.9em; margin-bottom: 8px;">
                                    <strong>Total:</strong> ${thirdStats.counts[t.key]} 
                                    <span style="color: #666;">(${(thirdStats.counts[t.key]/total*100).toFixed(1)}%)</span>
                                </div>
                                <div style="color: #333; font-size: 0.9em; margin-bottom: 8px;">
                                    <strong>🔥 Máx. racha:</strong> ${thirdStats.maxStreaks[t.key]} veces
                                </div>
                                <div style="color: #333; font-size: 0.9em;">
                                    <strong>❄️ Máx. sin salir:</strong> ${thirdStats.maxNoStreaks[t.key]} veces
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function calculateLimboAdvancedStats() {
            const sorted = [...calculatedResults].sort((a, b) => b.value - a.value);
            const top10 = sorted.slice(0, 10);

            displayTopMultipliers(top10);

            const thresholds = [30, 50, 100, 250, 500, 1000];
            const maxStreaks = {};
            
            thresholds.forEach(threshold => {
                let currentStreak = 0;
                let maxStreak = 0;
                
                calculatedResults.forEach(r => {
                    if (r.value < threshold) {
                        currentStreak++;
                        maxStreak = Math.max(maxStreak, currentStreak);
                    } else {
                        currentStreak = 0;
                    }
                });
                
                maxStreaks[threshold] = maxStreak;
            });

            displayLimboStreaks(maxStreaks);
        }

        function displayTopMultipliers(top10) {
            const container = document.getElementById('topMultipliersContainer');
            
            container.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.15);">
                    <div style="display: grid; gap: 12px;">
                        ${top10.map((item, index) => `
                            <div style="background: linear-gradient(135deg, ${index === 0 ? '#f39c12' : index === 1 ? '#95a5a6' : index === 2 ? '#cd7f32' : '#ecf0f1'}, 
                                ${index === 0 ? '#f1c40f' : index === 1 ? '#bdc3c7' : index === 2 ? '#d4915d' : '#f8f9fa'}); 
                                padding: 15px 20px; border-radius: 12px; display: flex; align-items: center; justify-content: space-between;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <div style="font-size: 1.8em; font-weight: 700; color: ${index < 3 ? 'white' : '#333'}; min-width: 40px;">
                                        ${index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `#${index + 1}`}
                                    </div>
                                    <div>
                                        <div style="font-size: 1.8em; font-weight: 700; color: ${index < 3 ? 'white' : '#e74c3c'};">
                                            ${item.value.toFixed(2)}x
                                        </div>
                                        <div style="font-size: 0.85em; color: ${index < 3 ? 'rgba(255,255,255,0.9)' : '#666'};">
                                            Nonce: ${item.nonce}
                                        </div>
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 0.8em; color: ${index < 3 ? 'rgba(255,255,255,0.8)' : '#999'};">
                                        Hash: ${item.hash}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function displayLimboStreaks(maxStreaks) {
            const container = document.getElementById('limboStreaksContainer');
            
            const thresholds = Object.entries(maxStreaks).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px;">
                    ${thresholds.map(([threshold, streak]) => {
                        const color = parseInt(threshold) >= 500 ? '#e74c3c' : 
                                     parseInt(threshold) >= 250 ? '#e67e22' :
                                     parseInt(threshold) >= 100 ? '#f39c12' :
                                     parseInt(threshold) >= 50 ? '#f1c40f' : '#3498db';
                        return `
                            <div style="background: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                                <div style="font-size: 1.2em; font-weight: 600; color: #666; margin-bottom: 10px;">
                                    Sin multi ≥${threshold}x
                                </div>
                                <div style="font-size: 2.5em; font-weight: 700; color: ${color}; margin-bottom: 5px;">
                                    ${streak}
                                </div>
                                <div style="font-size: 0.9em; color: #999;">
                                    tiradas consecutivas
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function calculateDiceAdvancedStats() {
            const extremes = {
                under0_1: calculatedResults.filter(r => r.value <= 0.1).length,
                under0_2: calculatedResults.filter(r => r.value <= 0.2).length,
                under0_5: calculatedResults.filter(r => r.value <= 0.5).length,
                under1: calculatedResults.filter(r => r.value <= 1).length,
                over99: calculatedResults.filter(r => r.value >= 99).length,
                over99_5: calculatedResults.filter(r => r.value >= 99.5).length,
                over99_8: calculatedResults.filter(r => r.value >= 99.8).length,
                over99_9: calculatedResults.filter(r => r.value >= 99.9).length
            };

            displayDiceExtremes(extremes);

            let maxStreakUnder1 = 0, currentStreakUnder1 = 0;
            let maxStreakOver99 = 0, currentStreakOver99 = 0;
            
            calculatedResults.forEach(r => {
                if (r.value > 1) {
                    currentStreakUnder1++;
                    maxStreakUnder1 = Math.max(maxStreakUnder1, currentStreakUnder1);
                } else {
                    currentStreakUnder1 = 0;
                }
                
                if (r.value < 99) {
                    currentStreakOver99++;
                    maxStreakOver99 = Math.max(maxStreakOver99, currentStreakOver99);
                } else {
                    currentStreakOver99 = 0;
                }
            });

            displayDiceStreaks({ maxStreakUnder1, maxStreakOver99 });
        }

        function displayDiceExtremes(extremes) {
            const container = document.getElementById('diceExtremesContainer');
            const total = calculatedResults.length;
            
            const extremeData = [
                { label: '≤ 0.1 (multi 1000x)', value: extremes.under0_1, color: '#e74c3c', side: 'bajo' },
                { label: '≤ 0.2 (multi 500x)', value: extremes.under0_2, color: '#e67e22', side: 'bajo' },
                { label: '≤ 0.5 (multi 250x)', value: extremes.under0_5, color: '#f39c12', side: 'bajo' },
                { label: '≤ 1.0 (multi 100x)', value: extremes.under1, color: '#f1c40f', side: 'bajo' },
                { label: '≥ 99.0 (multi 100x)', value: extremes.over99, color: '#3498db', side: 'alto' },
                { label: '≥ 99.5 (multi 250x)', value: extremes.over99_5, color: '#2980b9', side: 'alto' },
                { label: '≥ 99.8 (multi 500x)', value: extremes.over99_8, color: '#8e44ad', side: 'alto' },
                { label: '≥ 99.9 (multi 1000x)', value: extremes.over99_9, color: '#9b59b6', side: 'alto' }
            ];

            const lowTotal = extremes.under0_1 + extremes.under0_2 + extremes.under0_5 + extremes.under1;
            const highTotal = extremes.over99 + extremes.over99_5 + extremes.over99_8 + extremes.over99_9;

            container.innerHTML = `
                <div style="background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div style="text-align: center; padding: 15px; background: #fee; border-radius: 10px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total lado BAJO</div>
                            <div style="font-size: 2em; font-weight: 700; color: #e74c3c;">${lowTotal}</div>
                            <div style="font-size: 0.85em; color: #999;">(${(lowTotal/total*100).toFixed(2)}%)</div>
                        </div>
                        <div style="text-align: center; padding: 15px; background: #eef; border-radius: 10px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total lado ALTO</div>
                            <div style="font-size: 2em; font-weight: 700; color: #3498db;">${highTotal}</div>
                            <div style="font-size: 0.85em; color: #999;">(${(highTotal/total*100).toFixed(2)}%)</div>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                        ${extremeData.map(item => `
                            <div style="background: ${item.side === 'bajo' ? '#fef5f5' : '#f5f8fe'}; padding: 15px; border-radius: 10px; border-left: 4px solid ${item.color};">
                                <div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">${item.label}</div>
                                <div style="font-size: 1.8em; font-weight: 700; color: ${item.color};">${item.value}</div>
                                <div style="font-size: 0.8em; color: #999;">(${(item.value/total*100).toFixed(3)}%)</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function displayDiceStreaks(streaks) {
            const container = document.getElementById('diceStreaksContainer');
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                    <div style="background: white; padding: 25px; border-radius: 15px; text-align: center; box-shadow: 0 4px 15px rgba(0,0,0,0.15);">
                        <div style="font-size: 1.1em; color: #666; margin-bottom: 15px; font-weight: 600;">
                            Sin resultado <strong style="color: #e74c3c;">≤ 1.0</strong>
                        </div>
                        <div style="font-size: 3em; font-weight: 700; color: #e74c3c; margin-bottom: 10px;">
                            ${streaks.maxStreakUnder1}
                        </div>
                        <div style="font-size: 0.95em; color: #999;">
                            tiradas consecutivas
                        </div>
                    </div>
                    <div style="background: white; padding: 25px; border-radius: 15px; text-align: center; box-shadow: 0 4px 15px rgba(0,0,0,0.15);">
                        <div style="font-size: 1.1em; color: #666; margin-bottom: 15px; font-weight: 600;">
                            Sin resultado <strong style="color: #3498db;">≥ 99.0</strong>
                        </div>
                        <div style="font-size: 3em; font-weight: 700; color: #3498db; margin-bottom: 10px;">
                            ${streaks.maxStreakOver99}
                        </div>
                        <div style="font-size: 0.95em; color: #999;">
                            tiradas consecutivas
                        </div>
                    </div>
                </div>
            `;
        }

        function exportToExcel() {
            if (calculatedResults.length === 0) {
                alert('No hay resultados para exportar');
                return;
            }

            let excelData = [];
            const timestamp = new Date().toLocaleString('es-ES');
            const serverSeed = document.getElementById('serverSeed').value;
            const clientSeed = document.getElementById('clientSeed').value;

            switch(currentGame) {
                case 'roulette':
                    excelData = calculatedResults.map(r => ({
                        'Nonce': r.nonce,
                        'Número': r.value,
                        'Color': r.color,
                        'Par/Impar': r.value === 0 ? 'Verde' : (r.value % 2 === 0 ? 'Par' : 'Impar'),
                        'Alto/Bajo': r.value === 0 ? 'Verde' : (r.value <= 18 ? 'Bajo (1-18)' : 'Alto (19-36)'),
                        'Hash': r.hash
                    }));
                    break;

                case 'dice':
                    excelData = calculatedResults.map(r => ({
                        'Nonce': r.nonce,
                        'Resultado': r.value.toFixed(2),
                        'Bajo 50': r.value < 50 ? 'Sí' : 'No',
                        'Rango': r.value < 25 ? '0-25' : r.value < 50 ? '25-50' : r.value < 75 ? '50-75' : '75-100',
                        'Hash': r.hash
                    }));
                    break;

                case 'limbo':
                    excelData = calculatedResults.map(r => ({
                        'Nonce': r.nonce,
                        'Multiplicador': r.value.toFixed(2) + 'x',
                        'Valor Numérico': r.value.toFixed(4),
                        'Categoría': r.value < 2 ? '1-2x' : r.value < 5 ? '2-5x' : r.value < 10 ? '5-10x' : r.value < 50 ? '10-50x' : '50x+',
                        'Hash': r.hash
                    }));
                    break;

                case 'mines':
                    excelData = calculatedResults.map(r => ({
                        'Nonce': r.nonce,
                        'Posiciones Minas': r.display,
                        'Cantidad Minas': r.positions.length,
                        'Primera Mina': r.positions[0],
                        'Última Mina': r.positions[r.positions.length - 1],
                        'Hash': r.hash
                    }));
                    break;
            }

            const infoData = [
                ['Información de Verificación Provably Fair'],
                [''],
                ['Juego:', currentGame.toUpperCase()],
                ['Server Seed:', serverSeed],
                ['Client Seed:', clientSeed],
                ['Nonce Inicial:', document.getElementById('nonce').value],
                ['Total Tiradas:', calculatedResults.length],
                ['Fecha Exportación:', timestamp],
                [''],
                ['Estadísticas:']
            ];

            const stats = calculateStats();
            stats.forEach(stat => {
                infoData.push([stat.label + ':', stat.value]);
            });

            const wb = XLSX.utils.book_new();

            const wsInfo = XLSX.utils.aoa_to_sheet(infoData);
            XLSX.utils.book_append_sheet(wb, wsInfo, 'Información');

            const wsResults = XLSX.utils.json_to_sheet(excelData);
            
            const maxWidth = 50;
            const wscols = Object.keys(excelData[0] || {}).map(key => {
                const maxLen = Math.max(
                    key.length,
                    ...excelData.map(row => (row[key] || '').toString().length)
                );
                return { wch: Math.min(maxLen + 2, maxWidth) };
            });
            wsResults['!cols'] = wscols;

            XLSX.utils.book_append_sheet(wb, wsResults, 'Resultados');

            if (calculatedResults.length > 100) {
                let summaryData = [];
                
                if (currentGame === 'roulette') {
                    const distribution = {};
                    for (let i = 0; i <= 36; i++) distribution[i] = 0;
                    calculatedResults.forEach(r => distribution[r.value]++);
                    
                    summaryData = Object.entries(distribution).map(([num, count]) => ({
                        'Número': num,
                        'Frecuencia': count,
                        'Porcentaje': ((count / calculatedResults.length) * 100).toFixed(2) + '%'
                    }));
                } else if (currentGame === 'dice') {
                    for (let i = 0; i < 10; i++) {
                        const min = i * 10;
                        const max = (i + 1) * 10;
                        const count = calculatedResults.filter(r => r.value >= min && r.value < max).length;
                        summaryData.push({
                            'Rango': `${min}-${max}`,
                            'Frecuencia': count,
                            'Porcentaje': ((count / calculatedResults.length) * 100).toFixed(2) + '%'
                        });
                    }
                } else if (currentGame === 'limbo') {
                    const ranges = [
                        {label: '1-2x', min: 1, max: 2},
                        {label: '2-5x', min: 2, max: 5},
                        {label: '5-10x', min: 5, max: 10},
                        {label: '10-50x', min: 10, max: 50},
                        {label: '50x+', min: 50, max: Infinity}
                    ];
                    summaryData = ranges.map(range => {
                        const count = calculatedResults.filter(r => r.value >= range.min && r.value < range.max).length;
                        return {
                            'Rango': range.label,
                            'Frecuencia': count,
                            'Porcentaje': ((count / calculatedResults.length) * 100).toFixed(2) + '%'
                        };
                    });
                } else if (currentGame === 'mines') {
                    const positionFreq = {};
                    for (let i = 0; i < 25; i++) positionFreq[i] = 0;
                    calculatedResults.forEach(r => {
                        r.positions.forEach(pos => positionFreq[pos]++);
                    });
                    
                    summaryData = Object.entries(positionFreq).map(([pos, count]) => ({
                        'Posición': pos,
                        'Frecuencia': count,
                        'Porcentaje': ((count / (calculatedResults.length * parseInt(document.getElementById('minesCount').value))) * 100).toFixed(2) + '%'
                    }));
                }

                const wsSummary = XLSX.utils.json_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(wb, wsSummary, 'Resumen Estadístico');
            }

            const fileName = `Stake_${currentGame}_${serverSeed.substring(0, 8)}_${new Date().getTime()}.xlsx`;
            
            XLSX.writeFile(wb, fileName);
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                animation: slideIn 0.5s ease-out;
            `;
            notification.innerHTML = `
                <strong>✅ Excel exportado exitosamente</strong><br>
                <small>${calculatedResults.length} resultados exportados</small>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.5s ease-out';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }
    </script>
</body>
</html>
